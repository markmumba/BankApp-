// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: account.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const closeAccount = `-- name: CloseAccount :exec
DELETE FROM
  accounts
WHERE
  account_id = $1
`

func (q *Queries) CloseAccount(ctx context.Context, accountID int32) error {
	_, err := q.db.ExecContext(ctx, closeAccount, accountID)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO
  accounts (user_id, account_number, account_type, balance)
VALUES
  (
    $1,
    lpad(floor(random() * 10 ^ 15):: text, 15, '0'),
    $2,
    0.00
  ) RETURNING account_id, user_id, account_number, account_type, balance, date_opened
`

type CreateAccountParams struct {
	UserID      uuid.NullUUID
	AccountType string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount, arg.UserID, arg.AccountType)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.AccountNumber,
		&i.AccountType,
		&i.Balance,
		&i.DateOpened,
	)
	return i, err
}

const creditSaving = `-- name: CreditSaving :exec
UPDATE
  accounts
SET
  balance =  $1
WHERE
  account_id = $2
  AND account_type = 'savings'
`

type CreditSavingParams struct {
	Balance   string
	AccountID int32
}

func (q *Queries) CreditSaving(ctx context.Context, arg CreditSavingParams) error {
	_, err := q.db.ExecContext(ctx, creditSaving, arg.Balance, arg.AccountID)
	return err
}

const debitChecking = `-- name: DebitChecking :exec
UPDATE
  accounts
SET
  balance = $1
WHERE
  account_id = $2
  AND account_type = 'checking'
`

type DebitCheckingParams struct {
	Balance   string
	AccountID int32
}

func (q *Queries) DebitChecking(ctx context.Context, arg DebitCheckingParams) error {
	_, err := q.db.ExecContext(ctx, debitChecking, arg.Balance, arg.AccountID)
	return err
}

const deposit = `-- name: Deposit :one
UPDATE
  accounts
SET
  balance = $1
WHERE
  account_id = $2 RETURNING account_id, user_id, account_number, account_type, balance, date_opened
`

type DepositParams struct {
	Balance   string
	AccountID int32
}

func (q *Queries) Deposit(ctx context.Context, arg DepositParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, deposit, arg.Balance, arg.AccountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.AccountNumber,
		&i.AccountType,
		&i.Balance,
		&i.DateOpened,
	)
	return i, err
}

const findAccount = `-- name: FindAccount :many
SELECT
  u.user_id,
  u.username,
  a.account_id,
  a.account_number,
  a.account_type,
  a.balance
FROM
  users u
  JOIN accounts a ON u.user_id = a.user_id
WHERE
  u.user_id = $1
`

type FindAccountRow struct {
	UserID        uuid.UUID
	Username      string
	AccountID     int32
	AccountNumber string
	AccountType   string
	Balance       string
}

func (q *Queries) FindAccount(ctx context.Context, userID uuid.UUID) ([]FindAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, findAccount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAccountRow
	for rows.Next() {
		var i FindAccountRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.AccountID,
			&i.AccountNumber,
			&i.AccountType,
			&i.Balance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const viewTransactions = `-- name: ViewTransactions :many
SELECT
  transaction_id, account_id, recepient_id, amount, type, timestamp
FROM
  transactions
WHERE
  account_id = $1
  OR recepient_id = $1
ORDER BY
  timestamp DESC
`

func (q *Queries) ViewTransactions(ctx context.Context, accountID sql.NullInt32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, viewTransactions, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.AccountID,
			&i.RecepientID,
			&i.Amount,
			&i.Type,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const withdraw = `-- name: Withdraw :one
UPDATE
  accounts
SET
  balance = $1
WHERE
  account_id = $2 RETURNING account_id, user_id, account_number, account_type, balance, date_opened
`

type WithdrawParams struct {
	Balance   string
	AccountID int32
}

func (q *Queries) Withdraw(ctx context.Context, arg WithdrawParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, withdraw, arg.Balance, arg.AccountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.AccountNumber,
		&i.AccountType,
		&i.Balance,
		&i.DateOpened,
	)
	return i, err
}
